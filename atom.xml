<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason&#39;s blog</title>
  
  <subtitle>We are in the same story.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mazhixian.me/"/>
  <updated>2018-03-04T02:46:30.801Z</updated>
  <id>http://www.mazhixian.me/</id>
  
  <author>
    <name>Jason Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nupy矩阵的复制问题</title>
    <link href="http://www.mazhixian.me/2018/03/04/a-numpy-matrix-copy-problem/"/>
    <id>http://www.mazhixian.me/2018/03/04/a-numpy-matrix-copy-problem/</id>
    <published>2018-03-04T02:26:23.000Z</published>
    <updated>2018-03-04T02:46:30.801Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下最近遇到的一个bug，利用numpy生成的矩阵在复制时不能直接赋值，而是要用<code>copy</code>方法。直接赋值类似于把内存中的地址 (即指针) 给了目标变量，其与被赋值变量共享同一块内存，这样做可以节省内存空间。而<code>copy</code>则不同，会重新申请一块内存，分配给复制后的新变量，在该变量上的操作不会对愿变量产生影响。</p><p>下面看一个例子,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">x = np.arange(<span class="number">9.</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</div><div class="line"><span class="comment"># copy</span></div><div class="line">y = x.copy()</div><div class="line">y[y&gt;=<span class="number">5</span>] = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment"># 赋值法</span></div><div class="line">z = x</div><div class="line">z[z&gt;=<span class="number">5</span>] = <span class="number">0</span></div></pre></td></tr></table></figure></p><p>其输出结果如下,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">6</span>]: y</div><div class="line">Out[<span class="number">6</span>]: </div><div class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</div><div class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>],</div><div class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</div><div class="line"></div><div class="line">In [<span class="number">7</span>]: x</div><div class="line">Out[<span class="number">7</span>]: </div><div class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</div><div class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</div><div class="line">       [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</div><div class="line"></div><div class="line">In [<span class="number">8</span>]: z</div><div class="line">Out[<span class="number">8</span>]: </div><div class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</div><div class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>],</div><div class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</div><div class="line"></div><div class="line">In [<span class="number">9</span>]: x</div><div class="line">Out[<span class="number">9</span>]: </div><div class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</div><div class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>],</div><div class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</div></pre></td></tr></table></figure></p><p>可以看到，采用<code>copy</code>后，对<code>y</code>的操作不会影响到原矩阵<code>x</code>，而采用直接赋值后，对<code>z</code>的操作对<code>x</code>产生了影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单记录一下最近遇到的一个bug，利用numpy生成的矩阵在复制时不能直接赋值，而是要用&lt;code&gt;copy&lt;/code&gt;方法。直接赋值类似于把内存中的地址 (即指针) 给了目标变量，其与被赋值变量共享同一块内存，这样做可以节省内存空间。而&lt;code&gt;copy&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="python" scheme="http://www.mazhixian.me/all-tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Upgrade Ubuntu from 1610 to 1710</title>
    <link href="http://www.mazhixian.me/2018/02/28/upgrade-ubuntu-from-1610-to-1710/"/>
    <id>http://www.mazhixian.me/2018/02/28/upgrade-ubuntu-from-1610-to-1710/</id>
    <published>2018-02-28T02:59:38.000Z</published>
    <updated>2018-02-28T03:19:56.626Z</updated>
    
    <content type="html"><![CDATA[<p>考虑到系统的稳定性，也因为懒，一直没升级Ubuntu 1610，也没有update。最近发现官方已经不支持1610了，而且直接把<code>yakkety</code>的镜像给取消了。所以，即使是利用系统自带的update manager，也无法直接升级到1710，会出现如下的两类错误，</p><h5 id="无法更新"><a href="#无法更新" class="headerlink" title="无法更新"></a>无法更新</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">E:The repository <span class="string">'http://archive.canonical.com/ubuntu yakkety Release'</span> does not have a Release file., </div><div class="line">W:Updating from such a repository can<span class="string">'t be done securely, and is therefore disabled by default., </span></div><div class="line"><span class="string">W:See apt-secure(8) manpage for repository creation and user configuration details., </span></div><div class="line"><span class="string">E:The repository '</span>http://archive.ubuntu.com/ubuntu yakkety Release<span class="string">' does not have a Release file., </span></div><div class="line"><span class="string">W:Updating from such a repository can'</span>t be <span class="keyword">done</span> securely, and is therefore disabled by default., </div><div class="line">W:See apt-secure(8) manpage <span class="keyword">for</span> repository creation and user configuration details., </div><div class="line">E:The repository <span class="string">'http://archive.ubuntu.com/ubuntu yakkety-updates Release'</span> does not have a Release file., </div><div class="line">...</div></pre></td></tr></table></figure><h5 id="无法升级"><a href="#无法升级" class="headerlink" title="无法升级"></a>无法升级</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">An upgrade from <span class="string">'yakkety'</span> to <span class="string">'artful'</span> is not supported with this tool.</div></pre></td></tr></table></figure><p>参考Askubuntu上的<a href="https://askubuntu.com/questions/997047/how-to-update-ubuntu-from-16-10-to-17-10" target="_blank" rel="external">问题</a>，有如下的解决方法，<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/apt/</div><div class="line"><span class="comment"># 备份现有的sources.list</span></div><div class="line">sudo cp sources.list sources.list.bkp</div><div class="line"><span class="comment"># 替换yakkety为artful</span></div><div class="line">sudo vim sources.list</div><div class="line">:%s/yakkety/artful/g</div><div class="line"><span class="comment"># 保存并重新更新和升级</span></div><div class="line">sudo update</div><div class="line">sudo upgrade</div><div class="line"><span class="comment"># 重启系统</span></div><div class="line">reboot</div></pre></td></tr></table></figure></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] <a href="https://askubuntu.com/questions/997047/how-to-update-ubuntu-from-16-10-to-17-10" target="_blank" rel="external">How to upgrade ubuntu from 1610 to 1710</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考虑到系统的稳定性，也因为懒，一直没升级Ubuntu 1610，也没有update。最近发现官方已经不支持1610了，而且直接把&lt;code&gt;yakkety&lt;/code&gt;的镜像给取消了。所以，即使是利用系统自带的update manager，也无法直接升级到1710，会出现如
      
    
    </summary>
    
    
      <category term="linux" scheme="http://www.mazhixian.me/all-tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Python和MATLAB矩阵索引的一个区别</title>
    <link href="http://www.mazhixian.me/2018/02/27/difference-of-indexing-between-python-and-matlab/"/>
    <id>http://www.mazhixian.me/2018/02/27/difference-of-indexing-between-python-and-matlab/</id>
    <published>2018-02-27T02:04:15.000Z</published>
    <updated>2018-02-27T02:36:29.198Z</updated>
    
    <content type="html"><![CDATA[<p>这两天尝试将一个MATLAB工程转成Python，卡在一个bug上很久，最后发现是二者在矩阵索引上存在区别。这里我采用的是Python的<a href="https://www.numpy.org" target="_blank" rel="external">NumPy</a>库。</p><p>我们经常会通过一定的逻辑关系索引矩阵中的元素，并获取这些元素的位置信息，即indices。例如，<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">% MATLAB实现</span></div><div class="line">x = resize(<span class="number">0</span>:<span class="number">8</span>, <span class="number">3</span>, <span class="number">3</span>);</div><div class="line"><span class="comment">% 一维索引</span></div><div class="line">idx = <span class="built_in">find</span>(x &gt;= <span class="number">3</span>);</div><div class="line"><span class="comment">% 二维索引</span></div><div class="line">[idr, idc] = <span class="built_in">find</span>(x &gt;= <span class="number">3</span>);</div></pre></td></tr></table></figure></p><p>对应的python实现为，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">x = np.arange(<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</div><div class="line"><span class="comment"># 只有二维索引</span></div><div class="line">[idr, idc] = np.where(x &gt;= <span class="number">3</span>)</div></pre></td></tr></table></figure></p><p>这里可以看出，MATLAB提供一种一维索引，即将二维矩阵以列为先，行次之转为一维向量，输出的索引对应该一维向量中元素所在位置。（这种处理方法经常可以用于加速运算，缩短运行时间。）然而，NumPy的where方法根据矩阵的维数提供对应axis的索引，没有MATLAB这种一维索引的输出。</p><p>因此，在python中使用np.where进行矩阵元素索引时，要注意如下两点，</p><ol><li>np.where的输出是一个列表;</li><li>np.where的输出列表的元素个数与矩阵的维数对应。</li></ol><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html" target="_blank" rel="external">numpy.where</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两天尝试将一个MATLAB工程转成Python，卡在一个bug上很久，最后发现是二者在矩阵索引上存在区别。这里我采用的是Python的&lt;a href=&quot;https://www.numpy.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NumPy&lt;
      
    
    </summary>
    
    
      <category term="python" scheme="http://www.mazhixian.me/all-tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Curve fitting by SciPy</title>
    <link href="http://www.mazhixian.me/2018/02/26/Curve-fitting-by-scipy/"/>
    <id>http://www.mazhixian.me/2018/02/26/Curve-fitting-by-scipy/</id>
    <published>2018-02-26T02:09:33.000Z</published>
    <updated>2018-02-26T02:49:22.826Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下利用python的<a href="https://www.scipy.org" target="_blank" rel="external">SciPy</a>库进行曲线拟合的方法，主要分为三个步骤，(1) 获取待拟合数据; (2) 定义函数描述待拟合曲线; （3）利用<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html" target="_blank" rel="external">Scipy.optimize.curve_fit</a>模块进行拟合。</p><p>获取数据的步骤不再赘述，这里从步骤二开始。以泊松分布为例，首先定义函数<code>poisson_func</code>，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">poisson_func</span><span class="params">(k, l, c)</span>:</span></div><div class="line"><span class="string">"""Poisson function</span></div><div class="line"><span class="string">    inputs</span></div><div class="line"><span class="string">    ======</span></div><div class="line"><span class="string">    k: np.ndarray</span></div><div class="line"><span class="string">       number of accidents, i.e., the x axis;</span></div><div class="line"><span class="string">    l: double</span></div><div class="line"><span class="string">       the lambda parameter of Poisson distribution</span></div><div class="line"><span class="string">    c: double</span></div><div class="line"><span class="string">       a constant for release the optimization</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    output</span></div><div class="line"><span class="string">    ======</span></div><div class="line"><span class="string">    the fitted result according to l and c w.r.t. k</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    note</span></div><div class="line"><span class="string">    ====</span></div><div class="line"><span class="string">    l and c are the parametres to be estimated.</span></div><div class="line"><span class="string">    """</span></div><div class="line">    k_mat = np.ones(k.shape)</div><div class="line">    <span class="keyword">for</span> x, i <span class="keyword">in</span> enumerate(k):</div><div class="line">        k_mat[i] = math.factorial(x) </div><div class="line">    <span class="keyword">return</span> l**k / k_mat*np.exp(-l) + c</div></pre></td></tr></table></figure></p><p>紧接着，根据待拟合的数据，对参数进行估计，如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</div><div class="line"></div><div class="line">popt, pcov = curve_fit(poisson_func, x, y)</div><div class="line">perr = np.sqrt(np.diag(pcov))</div></pre></td></tr></table></figure></p><p>其中<code>popt</code>为估计的参数，<code>pcov</code>为对应的相关矩阵，其对角线为方差，可用于计算拟合参数的误差perr。</p><p>下图为我的测试样例，图中橙色三角为待拟合样本点，蓝色实线为拟合结果。</p><center><img src="https://github.com/myinxd/canal-images/blob/master/images/blog-180226/fig1.png?raw=true" height="300" width="430"></center><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>[1] <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html" target="_blank" rel="external">Scipy.optimize.curve_fit</a><br>[2] <a href="https://en.wikipedia.org/wiki/Poisson_distribution" target="_blank" rel="external">Poisson distribution</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单记录一下利用python的&lt;a href=&quot;https://www.scipy.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SciPy&lt;/a&gt;库进行曲线拟合的方法，主要分为三个步骤，(1) 获取待拟合数据; (2) 定义函数描述待拟合曲线; 
      
    
    </summary>
    
    
      <category term="python" scheme="http://www.mazhixian.me/all-tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Happy Chinese new year</title>
    <link href="http://www.mazhixian.me/2018/02/15/happy-chinese-new-year/"/>
    <id>http://www.mazhixian.me/2018/02/15/happy-chinese-new-year/</id>
    <published>2018-02-15T09:09:57.000Z</published>
    <updated>2018-02-15T09:15:34.765Z</updated>
    
    <content type="html"><![CDATA[<p>Nothing to tell, ‘cause I am out of work for a week, lol. A warm greeting from my hometown that happy Chinese new year. Also a celebrationg for my 400th contribution to my github.</p><p>Wish everything well in the new year.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nothing to tell, ‘cause I am out of work for a week, lol. A warm greeting from my hometown that happy Chinese new year. Also a celebratio
      
    
    </summary>
    
    
      <category term="life" scheme="http://www.mazhixian.me/all-tags/life/"/>
    
  </entry>
  
  <entry>
    <title>Write a blog by Hexo</title>
    <link href="http://www.mazhixian.me/2018/02/07/write-a-blog-by-hexo/"/>
    <id>http://www.mazhixian.me/2018/02/07/write-a-blog-by-hexo/</id>
    <published>2018-02-07T14:30:21.000Z</published>
    <updated>2018-02-07T14:49:47.453Z</updated>
    
    <content type="html"><![CDATA[<p>写之前吐个槽，连续的熬夜加酗酒，要跪。。。睡前写个hexo相关的教程，基于hexo如何撰写和发布一篇博客。主要分为两步，(1) 掌握markdown语法和git相关指令; (2) 利用hexo命令初始和编译文章。</p><h4 id="Markdown语法和git相关指令"><a href="#Markdown语法和git相关指令" class="headerlink" title="Markdown语法和git相关指令"></a>Markdown语法和git相关指令</h4><p>Markdown的基本语法可以参考<a href="http://blog.sina.com.cn/s/blog_9b6253b10102x998.html" target="_blank" rel="external">这篇文章</a>，在博客中主要会用到三种语法结构，</p><ul><li>标题控制 用#，#号数量越多，标题级别越低;</li><li>超链接： 形如<code>[name](address)</code>;</li><li>图像: 形如<code>![name](address)</code> 注意感叹号。</li></ul><p>而git相关的指令，用于上传图片，作为图床。主要指令有，</p><ul><li>git add xxx : 添加一个需要push的文件;</li><li>git commit -m “xxx”: 给这次push添加commitp;</li><li>git push： 将commit的文件推送到git仓库中。</li></ul><h4 id="利用Hexo命令初始、编译和发布文章"><a href="#利用Hexo命令初始、编译和发布文章" class="headerlink" title="利用Hexo命令初始、编译和发布文章"></a>利用Hexo命令初始、编译和发布文章</h4><p>Hexo 的安装和配置参考<a href="http://www.mazhixian.me/2017/08/23/Build-your-blog/">这篇文章</a>，这里只介绍新文章的生成过程。</p><ol><li><p>新建一篇名为xxx的文章，此时在blog/source/_posts路径下会生成名为’xxx.md’的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> blog</div><div class="line">$ hexo new <span class="string">"xxx"</span></div></pre></td></tr></table></figure></li><li><p>编写文章</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ./<span class="built_in">source</span>/_posts</div><div class="line">$ vim xxx.md</div></pre></td></tr></table></figure></li></ol><p>或者可以利用markdown相关的编辑器，如<a href="http://pad.haroopress.com/user.html" target="_blank" rel="external">haroopad</a>，这是一款非常好用的编辑器。</p><ol><li>编译、预览和发布文章<br>利用如下命令可以编译、预览和发布文章，<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo g <span class="comment"># 编译</span></div><div class="line">$ hexo s <span class="comment"># 预览，此时在浏览器输入 localhost:4000</span></div><div class="line">$ hexo d <span class="comment"># 发布文章到github</span></div></pre></td></tr></table></figure></li></ol><p>Enjoy it~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写之前吐个槽，连续的熬夜加酗酒，要跪。。。睡前写个hexo相关的教程，基于hexo如何撰写和发布一篇博客。主要分为两步，(1) 掌握markdown语法和git相关指令; (2) 利用hexo命令初始和编译文章。&lt;/p&gt;
&lt;h4 id=&quot;Markdown语法和git相关指令
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://www.mazhixian.me/all-tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Train selected variables in tensorflow graph</title>
    <link href="http://www.mazhixian.me/2018/02/04/train-selected-variables-in-tensorflow-graph/"/>
    <id>http://www.mazhixian.me/2018/02/04/train-selected-variables-in-tensorflow-graph/</id>
    <published>2018-02-03T18:02:44.000Z</published>
    <updated>2018-02-03T18:15:17.695Z</updated>
    
    <content type="html"><![CDATA[<p>写之前吐个槽，我又把<code>tf.nn.softmax_cross_entropy_with_logits</code>的参数赋反了，折腾了一晚上。。。这篇文章主要讨论TensorFlow中训练指定变量的问题。这篇<a href="http://blog.csdn.net/shwan_ma/article/details/78881961" target="_blank" rel="external">博客</a>给了个非常巧妙的方法，简单记录一下。</p><h4 id="1-查看可训练的参数及其index"><a href="#1-查看可训练的参数及其index" class="headerlink" title="1. 查看可训练的参数及其index"></a>1. 查看可训练的参数及其index</h4><p>在<code>tf.trainiable_variables</code>里存储了可以用于训练的变量，利用如下方法可以打印出它们的信息，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">variables_names = [v.name <span class="keyword">for</span> v <span class="keyword">in</span> tf.trainable_variables()]</div><div class="line">values = sess.run(variables_names)</div><div class="line">i = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> zip(variables_names, values):</div><div class="line">    print(i, <span class="string">"Variable: "</span>, k)</div><div class="line">    print(<span class="string">"Shape: "</span>, v.shape)</div><div class="line">    i += <span class="number">1</span></div></pre></td></tr></table></figure></p><h4 id="2-建立train-options，并为其提供不同的trainable-lists"><a href="#2-建立train-options，并为其提供不同的trainable-lists" class="headerlink" title="2. 建立train options，并为其提供不同的trainable lists"></a>2. 建立train options，并为其提供不同的trainable lists</h4><p>假设有两个loss function，分别对应网络中不同区域的变量，为了实现梯度的有效传递，可以利用如下方法，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">loss1 = ...</div><div class="line">loss2 = ...</div><div class="line">var_list1 = tf.trainable_variables()[<span class="number">0</span>:<span class="number">10</span>]</div><div class="line">var_list2 = tf.trainable_variables()[<span class="number">10</span>:]</div><div class="line">train_op1 = tf.train.AdamOptimizer(learning_rate).minimize(loss1, var_list=var_list1)</div><div class="line">train_op2 = tf.train.AdamOptimizer(learning_rate).minimize(lose2, var_list=var_list2)</div></pre></td></tr></table></figure></p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p>[1] <a href="http://blog.csdn.net/shwan_ma/article/details/78881961" target="_blank" rel="external">[tensorflow] 在不同层上设置不同的学习率，fine-tuning</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写之前吐个槽，我又把&lt;code&gt;tf.nn.softmax_cross_entropy_with_logits&lt;/code&gt;的参数赋反了，折腾了一晚上。。。这篇文章主要讨论TensorFlow中训练指定变量的问题。这篇&lt;a href=&quot;http://blog.csdn.ne
      
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://www.mazhixian.me/all-tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>Transpose convolution by tensorflow--odd kernel shape</title>
    <link href="http://www.mazhixian.me/2018/01/31/transpose-convolution-by-tensorflow/"/>
    <id>http://www.mazhixian.me/2018/01/31/transpose-convolution-by-tensorflow/</id>
    <published>2018-01-31T02:07:44.000Z</published>
    <updated>2018-01-31T07:34:06.969Z</updated>
    
    <content type="html"><![CDATA[<p>The auto-encoder has been applied widely for unsupervised learning, which is usually composed of two symmetric parts namely encoder and decoder. It is easy to realize an autoencoder only with fully-connected layers, i.e., DNN, but which is not that clear in CNN. </p><p>For convolution case, the layer in the decoder maintains the shape and kernel configurations for its symmetric layer in the encoder, thus the deconvolution, or <a href="deeplearning.net/software/theano_versions/dev/tutorial/conv_arithmetic.html#transposed-convolution-arithmetic">transpose convolution</a> operation will be used instead of the convolution operation.</p><p>TensorFlow provides a method namedly <code>conv2d_transpose</code> in both <code>tf.nn</code> module and <code>tf.contrib.layers</code> module, which are very convenient. However, for <code>tf.contrib.layers.conv2d_transpose</code>, if the output shape of the transpose convolutution is odd when convolution stride setting as 2, it cannot control the output shape to desired one. </p><p>For example, denote a [None, 9, 9, 1] 4D-tensor $X$, convolved by a kernel of size [3, 3] with a 2 step stride and halp padding (SAME), the output 4D tensor $y$ will be [None, 5, 5, 1]. However, the transpose convolution from y by the same parameters setting generates $x’$ into a [None, 10, 10, 1] tensor, not [None, 9, 9, 1].  </p><p>To handle this, I provide a naive but effective way, see as follows,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">import</span> tensorflow.contrib.layers <span class="keyword">as</span> layers</div><div class="line"></div><div class="line">x = tf.placeholder(tf.float32, shape=[<span class="keyword">None</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>])</div><div class="line">y = tf.placeholder(tf.float32, shape=[<span class="keyword">None</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">1</span>])</div><div class="line">kernel_size = [<span class="number">3</span>, <span class="number">3</span>]</div><div class="line">stride = <span class="number">2</span></div><div class="line"></div><div class="line">x_r = layers.conv2d_transpose(</div><div class="line">        inputs=x,</div><div class="line">        num_outputs=x.get_shape().as_list()[<span class="number">1</span>],</div><div class="line">        kernel_size=kenerl_size,</div><div class="line">        padding=<span class="string">'SAME'</span>,</div><div class="line">        stride=stride,</div><div class="line">        scope=<span class="string">'conv2d_transpose'</span></div><div class="line">        )</div><div class="line"></div><div class="line">x_r = x_r[:, <span class="number">0</span>:<span class="number">-1</span>, <span class="number">0</span>:<span class="number">-1</span>, :]</div></pre></td></tr></table></figure><p>Above solution played well in my code, though ths crop may introduce bias..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;The auto-encoder has been applied widely for unsupervised learning, which is usually composed of two symmetric parts namely encoder and d
      
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://www.mazhixian.me/all-tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>Upsampling for 2D convolution by tensorflow</title>
    <link href="http://www.mazhixian.me/2018/01/27/upsampling-for-2D-convolution-by-tensorflow/"/>
    <id>http://www.mazhixian.me/2018/01/27/upsampling-for-2D-convolution-by-tensorflow/</id>
    <published>2018-01-27T08:56:22.000Z</published>
    <updated>2018-01-27T09:50:25.622Z</updated>
    
    <content type="html"><![CDATA[<p>A convolutional auto-encoder is usually composed of two sysmmetric parts, i.e., the encoder and decoder. By TensorFlow, it is easy to build the encoder part using modules like <a href="https://www.tensorflow.org/versions/r1.1/api_docs/python/tf/contrib/layers" target="_blank" rel="external">tf.contrib.layers</a> or <a href="https://www.tensorflow.org/api_docs/python/tf/nn" target="_blank" rel="external">tf.nn</a>, which encapsulate methods for convolution, downsampling, and dense operations. </p><p>However, as for the decoder part, TF does not provide method like <strong>upsampling</strong>, which is the reverse operation of downsampling (<code>avg_pool2, max_pool2</code>). This is because <strong>max pooling</strong> is applied more frequently than <strong>average pooling</strong>, while recover an image from max-pooled matrix is difficult for lossing of locations of the max points. </p><p>For the average-pooled feature maps, there is a simple way to realize upsampling without high-level API like <a href="https://keras.io" target="_blank" rel="external">keras</a>, but with basic functions of TF itself.</p><p>Now, suppose the input is a 4-D tenser whose shape is <code>[1, 4, 4, 1]</code> and sampling rate is <code>[1, 2, 2, 1]</code>, then the upsampled matrix is also a 4-D tenser of shape <code>[1, 8, 8, 1]</code>. Following lines can realize this operation.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line">x = tf.ones([<span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>])</div><div class="line">k = tf.ones([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]) <span class="comment"># note k.shape = [rows, cols, depth_in, depth_output]</span></div><div class="line">output_shape=[<span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">1</span>]</div><div class="line">y = tf.nn.conv2d_transpose(</div><div class="line">    value=x,</div><div class="line">    filter=k,</div><div class="line">    output_shape=output_shape,</div><div class="line">    strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</div><div class="line">    padding=<span class="string">'SAME'</span></div><div class="line">        )</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    print(sess.run(y))</div></pre></td></tr></table></figure><p>Then, y is the upsampled matrix.</p><p>You may also realize upsampling by the <code>resize_images</code> function of module<code>tf.image</code>, which is,<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">y = tf.image.resize_images(</div><div class="line">    images=x,</div><div class="line">    size=[<span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">1</span>],</div><div class="line">    method=ResizeMethod.NEAREST_NEIGHBOR</div><div class="line">        )</div></pre></td></tr></table></figure></p><p>Enjoy yourself.</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>[1] <a href="http://deeplearning.net/software/theano_versions/dev/tutorial/conv_arithmetic.html#transposed-convolution-arithmetic" target="_blank" rel="external">Transposed convolution arithmetic</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A convolutional auto-encoder is usually composed of two sysmmetric parts, i.e., the encoder and decoder. By TensorFlow, it is easy to bui
      
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://www.mazhixian.me/all-tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>Residual network II -- realization by tensorflow</title>
    <link href="http://www.mazhixian.me/2018/01/27/resnet-with-tensorflow-2/"/>
    <id>http://www.mazhixian.me/2018/01/27/resnet-with-tensorflow-2/</id>
    <published>2018-01-27T01:51:45.000Z</published>
    <updated>2018-01-27T03:16:16.718Z</updated>
    
    <content type="html"><![CDATA[<p>来填ResNet的坑，residual network的原理已经在<a href="http://www.mazhixian.me/2018/01/21/resnet-with-tensorflow/">上一篇</a>里做了介绍，这一篇来讨论如何用<a href="https://www.tensorflow.org" target="_blank" rel="external">TensorFlow</a>实现。</p><p>虽然TF提供了slim这个库，可以很方便地搭建网络，但考虑到移植和扩展性，还是决定用<code>tf.contrib.layers</code>的函数和tf基本的函数来写。我们知道，ResNet的核心模块是<strong>Bottleneck</strong>，如下图所示，每个bottleneck的输入会通过两条路径在输出汇聚，计算残差，作为下一层的输入。</p><center><img src="https://github.com/myinxd/canal-images/blob/master/images/blog-180127/fig_resnet.png?raw=true" height="150" width="450"></center><p>多个botleneck组合成一个block，通常会在每个block的最后一个bottleneck进行降采样，以缩小特征图大小。</p><p>具体的实现可以参考我的<a href="https://github.com/myinxd/canal-notebooks/blob/master/deeplearning/notebook_resnet13_digit_classification.ipynb" target="_blank" rel="external">notebook</a>, 下面贴一个在手写体识别样本上的测试结果，对比了<a href="http://www.mazhixian.me/2018/01/25/how-to-apply-the-batch-normalized-net/">这篇文章</a>里讨论的DNN网络。</p><center><img src="https://github.com/myinxd/canal-images/blob/master/images/blog-180127/fig_bn_res_cmp.png?raw=true" height="280" width="400"></center><p>可以看出ResNet的效果还是非常显著的。但是得强调一下，由于网络显著加深，训练时占用的显存资源非常大，普通的GPU非常吃力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来填ResNet的坑，residual network的原理已经在&lt;a href=&quot;http://www.mazhixian.me/2018/01/21/resnet-with-tensorflow/&quot;&gt;上一篇&lt;/a&gt;里做了介绍，这一篇来讨论如何用&lt;a href=&quot;http
      
    
    </summary>
    
    
      <category term="deep-learning" scheme="http://www.mazhixian.me/all-tags/deep-learning/"/>
    
  </entry>
  
</feed>
